package asd.creditCard.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import asd.creditCard.account.CCAccount;
import asd.creditCard.account.CCType;
import mum.asd.fw.account.Account;
import mum.asd.fw.account.AccountType;
import mum.asd.fw.account.IAccount;
import mum.asd.fw.common.Functor;
import mum.asd.fw.common.Predicate;
import mum.asd.fw.dao.IAccountDao;
import mum.asd.fw.dao.IAddressDao;
import mum.asd.fw.dao.ICustomerDao;
import mum.asd.fw.party.Address;
import mum.asd.fw.party.Company;
import mum.asd.fw.party.Customer;
import mum.asd.fw.party.Person;

public class HsqlAccountDao implements IAccountDao {
	private Connection connection;
	private IAddressDao addressDao;
	private ICustomerDao customerDao;

	public HsqlAccountDao(Connection connection, IAddressDao addressDao,
			ICustomerDao customerDao) {
		this.connection = connection;
		this.addressDao = addressDao;
		this.customerDao = customerDao;
	}

	public void insert(IAccount t) throws SQLException {
		// TODO Auto-generated method stub

		String query = " insert into ACCOUNT" + " values (null, ?, ?, ?,?,?)";

		// create the hsqldb insert preparedstatement
		PreparedStatement preparedStmt = connection.prepareStatement(query,
				Statement.RETURN_GENERATED_KEYS);

		customerDao.insert(t.getCustomer());
		// System.out.println(t.getCustomer().getId() + "*******************");
		preparedStmt.setInt(1, t.getCustomer().getId());
		preparedStmt.setString(2, t.getAccountType().toString());
		preparedStmt.setDouble(3, t.getBalance());
		preparedStmt.setString(4, t.getCCType().toString());
		preparedStmt.setString(5, t.getExpiryDate());
		Address a = t.getCustomer().getAddress();
		a.setCustomer(t.getCustomer());
		addressDao.insert(t.getCustomer().getAddress());

		// execute the preparedstatement

		preparedStmt.executeUpdate();

		// Get the value of autogenerated key in the database
		ResultSet keyResultSet = preparedStmt.getGeneratedKeys();
		int newAccountId = 0;
		if (keyResultSet.next()) {
			newAccountId = (int) keyResultSet.getInt(1);
		}

		// Assign autogenerated keys to the object
		t.setAccnr(newAccountId);
		preparedStmt.close();

	}

	public void update(IAccount t) throws SQLException {
		// TODO Auto-generated method stub
		String query = " UPDATE ACCOUNT set BALANCE = ? WHERE ACCOUNT_ID = ?";

		// create the hsqldb insert preparedstatement
		PreparedStatement preparedStmt = connection.prepareStatement(query);
		preparedStmt.setInt(2, t.getAccnr());
		preparedStmt.setDouble(1, t.getBalance());

		// execute the preparedstatement
		preparedStmt.executeUpdate();
		preparedStmt.close();

	}

	public void delete(Integer id) throws SQLException {
		// TODO Auto-generated method stub

		String query = " DELETE from ACCOUNT where ACCOUNT_ID = ?";

		// create the hsqldb insert preparedstatement
		PreparedStatement preparedStmt = connection.prepareStatement(query);
		preparedStmt.setInt(1, id);

		// execute the preparedstatement
		preparedStmt.executeUpdate();
		preparedStmt.close();

	}

	public Account getById(Integer id) throws SQLException {
		// TODO Auto-generated method stub
		String query = " SELECT * from ACCOUNT where ACCOUNT_ID = ? JOIN CUSTOMER ON CUSTOMER.CUSTOMER_ID = ACCOUNT.CUSTOMER_ID "
				+ " JOIN ADDRESS ON ADDRESS.CUSTOMER_ID = CUSTOMER.ADDRESS_ID";

		// create the hsqldb insert preparedstatement
		PreparedStatement preparedStmt = connection.prepareStatement(query);
		preparedStmt.setInt(1, id);

		// execute the preparedstatement
		ResultSet rs = preparedStmt.executeQuery();

		Account account = null;
		Customer customer = null;
		Address address = null;

		while (rs.next()) {
			address = new Address(rs.getString("ADDRESS.STREET"),
					rs.getString("ADDRESS.CITY"),
					rs.getString("ADDRESS.STATE"), rs.getInt("ADDRESS.ZIP"));
			customer = new Customer(rs.getString("CUSTOMER.NAME"), address);

			account = new CCAccount(customer);
		}
		preparedStmt.close();

		return account;
	}

	public List<IAccount> getAll() throws SQLException {
		// TODO Auto-generated method stub
		String query = "SELECT * FROM ACCOUNT JOIN (SELECT C.CUSTOMER_ID,C.TYPE, COALESCE(PC.NAME,CC.NAME) AS NAME,"
				+ "PC.DOB,CC.NO_OF_EMPLOYEES FROM CUSTOMER C LEFT JOIN "
				+ "PERSONAL_CUSTOMER PC ON C.CUSTOMER_ID=PC.CUSTOMER_ID LEFT JOIN COMPANY_CUSTOMER CC ON "
				+ "C.CUSTOMER_ID=CC.CUSTOMER_ID) CUST ON ACCOUNT.CUSTOMER_ID = CUST.CUSTOMER_ID JOIN ADDRESS "
				+ "ON CUST.CUSTOMER_ID=ADDRESS.CUSTOMER_ID";
		// String query = " SELECT * from ACCOUNT";
		List<IAccount> lstAccount = new ArrayList<IAccount>();
		// create the hsqldb insert preparedstatement
		PreparedStatement preparedStmt = connection.prepareStatement(query);

		// execute the preparedstatement
		ResultSet rs = preparedStmt.executeQuery();

		Account account = null;
		Customer customer = null;
		Address address = null;

		while (rs.next()) {
			address = new Address(rs.getString("ADDRESS.STREET"),
					rs.getString("ADDRESS.CITY"),
					rs.getString("ADDRESS.STATE"), rs.getInt("ADDRESS.ZIP"));
			String type = rs.getString("TYPE");
			if (type.trim().equals("C"))
				customer = new Company(rs.getString("NAME"), address,
						rs.getInt("NO_OF_EMPLOYEES"));
			else
				customer = new Person(rs.getString("NAME"), address,
						rs.getString("DOB"));

			account = new CCAccount(customer);
			account.setAccnr(rs.getInt("ACCOUNT.ACCOUNT_ID"));
			account.setBalance(rs.getDouble("ACCOUNT.BALANCE"));
			String str = rs.getString("ACCOUNT.CCTYPE").trim();
			if (CCType.BRONZE.toString().equals(str))
				account.setCCType(CCType.BRONZE);
			else if (CCType.GOLD.toString().equals(str))
				account.setCCType(CCType.GOLD);
			else
				account.setCCType(CCType.SILVER);
			account.setExpiryDate(rs.getString("ACCOUNT.EXPDATE"));
			//System.out.println(account.getExpiryDate());
			lstAccount.add(account);
		}
		preparedStmt.close();
		return lstAccount;
	}

	public <R> void doAll(Functor<IAccount, R> func, Predicate<IAccount> p)
			throws SQLException {
		List<IAccount> all = getAll();
		for (IAccount account : all) {
			func.execute(account);
		}

	}

}
